---
title: "Vignette_almaso"
author: "almaso"
date: "2023-01-20"
output: html_document
---

```{r setup, include=FALSE}
library(knitr)
knitr::opts_chunk$set(fig.height = 5, fig.width = 5, fig.align = "center", echo=TRUE, warning=FALSE, message=FALSE, cache=TRUE)
source("almaso_pipeline.R", local = knitr::knit_global())
```

# **Vignette: Flow cytometry data analysis workflow**

With this workflow, you will be able to analyse your flow cytometry data as single cell RNAseq data. The goal of the project was to build a pipeline to analyze flow cytometry data in the manner of scRNA-Seq.

The functions used in this vignette are stored in the *pipeline_functions.R .* To sum up, the pipeline goes through all those steps:

1.  [Load the datas]

2.  [Pre-processing]

3.  [Dimension Reduction]

4.  [Clustering]

5.  [Differential expression and identification of markers]

6.  [Biological interpretation]

This present vignette will show you how to use the function implemented in this pipeline and the justification behind the choice made.

### Libraries

Be careful to really import all packages present in the environment. The *renv* environment store every package necessary in the right version.

```{r libraries}
{
  library(flowCore)
  library(flowAI)
  library(ggcyto)
  library(PeacoQC)
  library(data.table)
  library(Seurat)
  library(ggplot2)
  library(tidyverse)
  library(gridExtra)
  library(ggrepel)
  library(dplyr)
  library(uwot)
  library(DESeq2)
  library(FlowSOM)
  library(ggcorrplot)
  library(ggfortify)
  library(factoextra)
  library(NOISeq)
  library(edgeR)
}
```

## Load the datas

Flow Cytometry datas are stored in *.fcs* files. The library **flowCore** provides data structures and basic functions to deal with those kind of data. You can load the data as *flowFrame* or *flowSet*.

The *flowFrame* class represents the data contained in a FCS file. Load with the command *read.flowFrame*, a *flowFrame* contains:

-   a numeric matrix **exprs** of the raw measurement values ( columns = markers, rows = cells)

-   an object of class *AnnotatedDataFrame* **parameters** that describe the parameters (e.g., the measurement channels, stains, dynamic range)

-   additional annotation provided through keywords in the FCS file (**description**)

A *flowSet* is a countainer of one or multiple *flowFrame*. Because most of pre-processing functions are made for *flowSets,* in this vignette, we will load 2 datasets as *flowSets*: one is a sample of control and one is a sample of a tumor. The *.fcs* files used here are stored in the *data* directory. We load both as flowSets.

```{r load_data}
file_name_tumor = "VP4_Tumor_CD45+ cells.fcs"
path_tumor <- file.path("./data", file_name_tumor)
tumor_sample = read.flowSet(path_tumor, column.pattern = "Time", invert.pattern = TRUE, truncate_max_range = FALSE)

file_name_control = "Vp6_Control_CD45+ cells.fcs"
path_control <- file.path("./data", file_name_control)
control_sample = read.flowSet(path_control, column.pattern = "Time", invert.pattern = TRUE, truncate_max_range = FALSE)
```

Here are summarized some commands from the **flowCore** package that are useful to access and examine *flowSets* objects.For more informations, please reviews the **flowCore** Reference Manual (<https://bioconductor.org/packages/release/bioc/manuals/flowCore/man/flowCore.pdf>).

You can extract a particular *flowFrame* from a *flowSet* with the command below. Here, because *control-sample* only contains 1 *flowFrame*, we take the first and only.

```{r basic_command}
control_sample[[1]]  # Extract the 1st flowFrame of the control_sample flowSet
```

## Pre-processing

The first step of our pipeline is to preprocess the data in order to clean them for further analysis. Our preprocessing pipeline contains 3 steps :

-   **Compensation** : control the spillover phenomenon happening during the fluorescence detection

-   **Quality control** : remove outliers and anomalies.

-   **Normalization** : scale and normalization (TMM and logCPM) on the expression matrix.

### Compensation

The idea is to compensate for spillover between channels by applying a spillover matrix to a *flowFrame*. Some detectors may register fluorochrom signals that do not correspond to them. To compensate, we apply a spillover matrix (background and secondary signal for each channels) as a linear combination.

Some flow cytometry datasets may already be compensated, so be careful. Here our data were already compensate, so the code is only an example. We use the *compensate* function from **flowCore**.

```{r compensation, eval=FALSE, include=TRUE}
if(exists("tumor_sample[[1]]@description$`$SPILLOVER`")){
  comp.mat <- tumor_sample[[1]]@description$`$SPILLOVER`
  tumor_sample_comp <- compensate(tumor_sample, comp.mat)
}
```

### Quality control

The goal of quality control is to remove outliers and anomalies. For that, we choose 2 libraries that can both do QC.

First is **flowAI**. It guarantee the stability of flow rate (remove flowrates that deviate from the median), the stability of signal acquisition ( intensity should always stay the same, detect deviations to the mean) and also the signal dynamic range consistency (remove outliers with Z-score and negatives values). The *flow_auto_qc* is a function of the **flowAI** package. It will create a file with graphs to explain the analysis conducted.

```{r flowAi, eval = FALSE}
control_sample_qcAI <- flow_auto_qc(control_sample)
```

Second is **peacoQC**. It determines peaks on the channels in the *flowframe*. Then it will remove outliers and anomalies caused by e.g. clogs, changes in speed etc. by using an IsolationTree and/or the MAD method.

The *peaco_QC* function is from our package. It is using the *PeacoQC* function from the **peacoQC** package. The return object *control_sample_peacoQC* is a flowSet. A directory **PeacoQC_results** will be created, containing the data cleaned and some graphs.

```{r PeacoQC, message=TRUE, warning=TRUE}
names <- colnames(control_sample)
control_sample_peacoQC <- peaco_QC(control_sample, file_name_control)
```

To visualize the results of the cleaning method, the heat-map from PeacoQCHeatmap can be interesting.

```{r QCheatmap, eval=FALSE}
PeacoQCHeatmap("./PeacoQC_results/PeacoQC_report.txt")
```

### Normalization & scaling:

First we extract the expression matrix from the cleaned dataset.

```{r exp_mat}
exp_mat_control <- exprs(control_sample_peacoQC[[1]])
summary(exp_mat_control)
#expr_matrix <- exprs(control_sample_qcAI)
```

Let's visualize the cleaned data.

```{r distrib_avant, echo=FALSE}
dexmat <- as.data.frame(exp_mat_control)
boxplot(dexmat, col = rainbow(ncol(dexmat)))
```

To normalize data, we decided to treat the flow cytometry data as scRNA-Seq data. So we used logCPM normalization on the expression matrix. First the function *norm_cyto* sets every negative value of expression matrix to 0 and removes the non useful column (*Original_ID*). It then performs the logCPM normalisation.

```{r normalization, echo=TRUE}
exp_mat_cpm <- norm_cyto(exp_mat_control)
summary(exp_mat_cpm)
```

Let's now visualize the impact of normalization.

```{r boxplots}
dexmat2 <- as.data.frame(exp_mat_cpm)
boxplot(dexmat2, col =rainbow(ncol(dexmat2)))
```

### Some Plots to visualize

On aimerait voir si on peut déjà distinguer deux catégories de cellules (T et B). Pas vraiment le cas!!

```{r plotSSCFSC}
ggplot(as.data.frame(exp_mat_cpm), aes(`FSC-A`,`SSC-A`)) +  geom_jitter(color='Orange' )  +  labs(x = "FSC-A",y = "SSC-A",subtitle = "Plot FSC vs SSC")
```

## Dimension Reduction

Since our dataset is only 20 parameters wide, dimensionality reduction may not appear as useful. But in order to increase separation between clusters, a PCA is recommended. The function *PCA* is implemented such that we can choose the parameters on which the PCA will be applied.

Here we applied *PCA* from the 7th to the 19th parameters (markers) of the expression matrix cleaned and normalized. The function returns the plot of eigenvalues and save the result of the dimension reduction method in the object *pca*.

```{r PCA}
PCA(exp_mat_cpm, 7, 19)
summary(pca)
```

With this last plot, we can evaluate the number of axes that explain the data. With the function *choose_dims_PCA*, we are able to chose the number of dimension we want to keep, by putting it as parameters.

Here we take 5 as dimension =\> WHY????

```{r dim_PCA}
df_pca <- choose_dims_PCA(pca, 5)
#head(df_pca)
```

Let's visualize the first 2 axes of the axes we choose to keep.

```{r visuPCA}
ggplot(data = df_pca, aes_string(x = "PC1", y = "PC2")) + geom_point(size = 3, color= "orange")
```

Here with this graph we can have a look of all contribution of variables to the variance.

```{r contribution_pca}
fviz_contrib(pca, "var")
```

## Clustering

To form clusters in our data, the (KNN + Louvain) clustering is applied, which is the same clustering method used in Seurat for scRNA-Seq data analysis. The function *clustering_cyto* separate and cluster data on the data frame returned by the PCA. It then attach to the expression matrix, cleaned and normalized, a column (*cluster_id)* that associate to each cell its cluster's ID. The result, here stored as df_KNN, is a dataframe (expression matrix + cluster_id).

The third parameter of *clustering_cyto* is the resolution of the Louvain clustering method. It is recommended to opt for low resolution. By default, it is 0.5.

```{r umap}
df_KNN <- clustering_cyto(df_pca, exp_mat_cpm, 0.5)
head(df_KNN)
#df_KNN2 <- clustering_cyto(df_pca)
```

In order to have an approach similar to what is usually done on scRNA-Seq data, we decided to do a UMAP to display the clustering. The function *RunUMAP_cyto* plots the UMAP with the clusters and saves a data frame with the UMAP coordinates and the cluster associated to each cell.

```{r plot_umap, fig.height=6, fig.width=8}
plt_umap <- RunUMAP_cyto(df_KNN, df_pca)
plt_umap
```

On this graph, we can see some cluster.

### Heatmap and other plots

To have a better overview of the clusters, we can plot a heatmap. The *heatmap_cyto* function takes the as argument and plot the heatmap of mean expression of each marker in each cluster.

```{r heatmap_cluster, echo=TRUE, error=FALSE, message=FALSE, warning=FALSE}
heatmap_cyto(df_KNN)
```

Let's also plot the expression of a specific marker on the UMAP representation. Here we choose to plot the expression of marker "FSC-H".

```{r plt_markers}
plt_marker <- marker_expression(df_KNN,"FSC-H",umap_m)
plt_marker
```

```{r all_expression_markers, fig.height=11, fig.width=16, fig.align='center'}
myplots <- all_markers_expression(df_KNN,umap_m)
```

Faudrait se rendre compte comment sont répartie toutes les cellules dans chaque cluster =\> counts!

```{r count_plot}
df_KNN %>% group_by(cluster_id) %>% summarise(total_count=n(), .groups = 'drop') %>% ggplot(aes(x = cluster_id, y = total_count), color='orange') + geom_bar(stat = "identity") 
```

## Differential expression and identification of markers

For that we use the wilcox test on all the clusters and all the markers! Possiblement une fonction pour tout arranger!

In order to identify the cell types based on our clustering, we needed to identify the markers that had a significant differential expression among the clusters.

The function *findMarkers_cyto* performs Wilcoxon tests, which are non-parametric Student tests to compare two samples. Tests are conducted on all clusters for each marker. Then top expressed markers for each cluster are identified based on adjusted p-values and log fold changes, as is usually done to identify DEGs for RNA-Seq data. They are stored in *df_wilcox* dataframe.

```{r find_markers}
df_wilcox <- findMarkers_cyto(df_KNN)

# Let's choose some threshold to filter this dataframe:
threshold_pca <- 0.05
threshold_FC  <- 2.5

test <- df_wilcox %>% dplyr::filter(adj_pvalue < threshold_pca & FC > threshold_FC )
test
```

```{r wriite_csv}
write.csv(test, file = 'df_wilcox_pca.csv')
```

## Biological interpretation

With the top expressed markers for each cluster, you can identified the cellular type of each cluster. No functions are able to do that now, be can be implemented later on.

```{r tumor}
file_name_tumor = "VP4_Tumor_CD45+ cells.fcs"
path_tumor <- file.path("./data", file_name_tumor)
tumor_sample = read.flowSet(path_tumor, column.pattern = "Time", invert.pattern = TRUE, truncate_max_range = FALSE)


# Quality control
fsc_peaco_QC_t <- peaco_QC(tumor_sample, file_name_tumor)
exp_matr_t <- fsc_peaco_QC_t@frames[[file_name_tumor]]@exprs

# Normalisation
exp_matr_cpm_t <- norm_cyto(exp_matr_t)


```

```{r tumor2}
#Perform PCA
PCA(exp_matr_cpm_t, 7, 19)
df_pca_t <- choose_dims_PCA(pca, 5)

#Perform Clustering
df_KNN_t <- clustering_cyto(df_pca_t,exp_matr_cpm_t)

#Clustering Visualization
plt_umap_t <- RunUMAP_cyto(df_KNN_t, df_pca_t)
plt_umap_t

#Visualize markers in clusters
# heatmap_cyto(df_KNN_t)

#Perform differential analysis
test_tumor <- findMarkers_cyto(df_KNN_t)
write.csv(test_tumor, file = 'df_wilcox_tumor.csv')
```


```{r sessioninfos}
sessionInfo()
```

![](images/macha_tea_icon.png){width="50"}
